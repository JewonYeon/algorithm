/**
 * 링크
    -
 * 문제
    - Dummy라는 도스 게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다.
      뱀이 기어 다니다가, 벽 또는 자기 자신의 몸과 부딪히면 게임이 끝난다.
      게임은 N x N 정사각 보드 위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다.
      보드의 상하좌우 끝에는 벽이 있다. 게임을 시작할 때 뱀은 맨 위 맨 좌측에 위치하고 뱀의 길이는 1이다.
      뱀은 처음에 오른쪽을 향한다.
      뱀은 매 초마다 이동을 하는데 다음 규칙을 따른다

      - 먼저 뱀은 몸 길이를 늘려 머리를 다음 칸에 위치 시킨다.
      - 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
      - 만약 이동한 칸에 사과가 없다면, 몸 길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않늕다.

      사과의 위치와 뱀의 이동경로가 주어질때 이 게임이 몇 초에 끝나는지 계산해라.
 * 제한 조건
    - N : 보드의 크기 (2 <= N <= 100)
    - K : 사과의 개수 (0 <= K <= 100)
    - apples: [[행, 열], ...] (1행 1열애는 사과가 없다.)
    - L : 뱀의 방향 변환 횟수 (1 <= L <= 100)
    - moves : [[X초뒤, 방향 = C], ...]
 * 예시
    입력
      1. 6, 3, [[3,4], [2,5], [5,3]], 3, [[3, 'D'], [15, 'L'], [17, 'D']]
      2. 10, 4, [[1,2], [1,3], [1,4], [1,5]], 4, [[8,'D'],[10,'D'],[11,'D'],[13,'L']]
      3. 10, 5, [[1,5],[1,3],[1,2],[1,6],[1,7]], 4, [[8,'D'],[10,'D'],[11,'D'],[13,'L']]
    출력
      1. 9
      2. 21
      3. 13
 * 풀이
    1. while문 종료 조건
      1-1. 자신의 위치와 겹친다.
      1-2. 벽에 부딪힌다.
    2. time을 1씩 증가시키면서, moves[0]과 시간이 맞는 지 확인한다.
      2-1. 다를 경우 시간만 증가
        2-1-1. 종료 조건을 확인한다.
      2-2. 같을 경우
        2-2-1. 방향을 전환시킨다.
    3. 중간에 사과를 만날 경우,
      3-1. 현재 뱀의 몸 위치를 전부 기록한다.
 * ETC
    -
*/

function move(d, C) {
  if (C === 'L') {
    return (d + 3) % 4;
  } else {
    return (d + 1) % 4;
  }
}

function solution(N, K, apples, L, moves) {
  const map = Array.from({ length: N + 1}, () => new Array(N + 1).fill(0));

  for (let i = 0; i < K; i++) {
    const [row, col] = apples[i];
    map[row][col] = 1; // 사과가 있을 경우 1로 표기
  }

  // 북, 동, 남, 서
  const dy = [-1, 0, 1, 0];
  const dx = [0, 1, 0, -1];

  let y = 1;
  let x = 1; // 뱀의 머리 위치
  map[1][1] = 2; // 뱀이 차지하는 위치 = 2;
  let snake = [[y, x]]; // 뱀이 차지하는 위치 (꼬리가 앞쪽)

  let d = 1; // 현재 방향 1 = 동
  let d_index = 0; // moves에서 얻을 다음에 회전할 정보
  let time = 0;

  while(true) {
    const nY = y + dy[d];
    const nX = x + dx[d];

    // 맵 범위 안에 있고, 뱀의 몸통이 없는 위치일 경우 이동 가능
    if (1 <= nY && N >= nY && 1 <= nX && N >= nX && map[nY][nX] !== 2) {
      // 사과가 없을 경우 이동 후 꼬리제거
      if (map[nY][nX] === 0) {
        map[nY][nX] = 2;
        snake.push([nY, nX]);

        map[y][x] = 0;
        snake.shift();
      }
      // 사과기 있을 경우 유지
      if (map[nY][nX] === 1) {
        map[nY][nX] = 2;
        snake.push([nY, nX]);
      }
    } else {
      time += 1;
      break;
    }

    y = nY;
    x = nX;
    time += 1;
    if (d_index < L && time === moves[d_index][0]) {
      d = move(d, moves[d_index][1]);
      d_index += 1;
    }
  }
  return time;
}

console.log(solution(6, 3, [[3,4], [2,5], [5,3]], 3, [[3, 'D'], [15, 'L'], [17, 'D']]));
